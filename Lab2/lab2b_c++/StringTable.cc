// STRINGTABLE.CC
// A hash table mapping strings to their positions in the the pattern
// sequence You get to fill in the methods for this part.  
// Since we're passing around raw character strings, I've made 
// the match length a parameter of the hash table so we don't have to 
// keep figuring it out on each call.
//

#include "StringTable.h"

#include <iostream>
#include <cmath>
#include <cstring>

using namespace std;

//
// Create an empty table big enough to hold maxSize records.
//
StringTable::StringTable(int maxSize, int imatchLength)
: matchLength(imatchLength),m(maxSize)
{
    table = new LinkedHashEntry*[m];
    for (int i = 0; i < m; i++)
        table[i] = NULL;
}

//
// Insert a Record r into the table.  Return true if
// successful, false if the table is full.  You shouldn't ever
// get two insertions with the same key value, but you may
// simply return false if this happens.
//
bool StringTable::insert(Record *r)
{
    // Calculate the key for hashing
    int hash = toHashKey(r->key) % m;
    if (table[hash] == NULL) {
        table[hash] = new LinkedHashEntry(r);
        return true;
    } else {
        LinkedHashEntry *entry = table[hash];
        while (entry->getNext() != NULL)
            entry = entry->getNext();
        // we should check whether the entry already exist
        if (strncmp(entry->getRecord()->key,r->key,
                    matchLength) == 0)
            return false;
        else {
            entry->setNext(new LinkedHashEntry(r));
            return true;
        }
    }
}


//
// Delete a Record r from the table.  Note that you'll have to
// find the record first unless you keep some extra info in
// the Record structure.
//
void StringTable::remove(Record *r)
{
    // Calculate the key for hashing
    int hash = toHashKey(r->key) % m;
    if (table[hash] != NULL) {
        LinkedHashEntry *prevEntry = NULL;
        LinkedHashEntry *entry = table[hash];
        while (entry->getNext() != NULL && 
               (strncmp(entry->getRecord()->key,r->key,
                        matchLength) != 0)) {
            prevEntry = entry;
            entry = entry->getNext();
        }
        // check if we find the element
        if (strncmp(entry->getRecord()->key,r->key,
                    matchLength) == 0) {
            // the element is the head of the list
            if (prevEntry == NULL) {
                LinkedHashEntry *nextEntry = entry->getNext();
                delete entry;
                table[hash] = nextEntry;
            } else {
                // if not the head of the list
                LinkedHashEntry *next = entry->getNext();
                delete entry;
                prevEntry->setNext(next);
            }
        }
    }
}


//
// Find a record with a key matching the input.  Return the
// record if it exists, or NULL if no matching record is found.
//
Record *StringTable::find(const char *key)
{
    // Calculate the key for hashing
    int hash = toHashKey(key) % m;
    // flag to indicate over flow
    Record *record_found = NULL;

    if (table[hash] != NULL) {
        LinkedHashEntry *entry = table[hash];
        while (entry != NULL && 
               (strncmp(entry->getRecord()->key,key,
                        matchLength) != 0))
            entry = entry->getNext();
        if (entry != NULL)
            record_found = entry->getRecord();
    }
    // return the value
    return record_found;
}


//////////////////////////////////////////////////////////

// Convert a string key into an integer that serves as input to hash
// functions.  This mapping is based on the idea of a 
// linear-congruential
// pesudorandom number generator, in which successive values r_i are
// generated by computing
//    r_i = ( A * r_(i-1) + B ) mod M
// A is a large prime number, while B is a small increment thrown in
// so that we don't just compute successive powers of A mod M.
//
// We modify the above generator by perturbing each r_i, adding in
// the ith character of the string and its offset, to alter the
// pseudorandom sequence.
//
int StringTable::toHashKey(const char *s) const
{
    int A = 1952786893;
    int B = 367257;
    int v = B;

    for (int j = 0; j < matchLength; j++)
        v = A * (v + int(s[j]) + j) + B;

    if (v < 0) v = -v;
        return v;
}


